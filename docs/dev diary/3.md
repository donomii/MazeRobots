# Pathfinding and more jobs

We stop walking through walls

## Pathfinding

Now that there is a basic job system that makes the little robots walk around and pick things up, I need to add the code to make them walk around walls, rather than through them.

This gets talked about a lot in computer programming.  Partially because it is something that looks complicated but can still be taught in a lecture, and partially because it is a good introduction to algorithms, because it is the only one that everyone can understand instantly, the moment they look at it on a screen.  It's also surprisingly difficult to get right.

The first stop was to see if anyone else had written one.  The only candidate was an entry on Rosetta Code, which was written in such a way that I couldn't figure out how to use it as a module.  Or use it at all.  Literate programming has some way to go.

So I ended up writing my own, which was the usual storm of frustration and misery that happens every time I have to implement an algorithm like this.  I didn't fully understand how it worked, but two days later I have a much better grasp on the problem.

I ended up going with a simplified version of A*, that drops the "open set", or "fringe set".  There is probably an official name for this variant, but it would take me much too long to search for it.

When A* searches for paths, it keeps a list of every possible next step, in order, and always tries to extend the shortest path.  This guarantees that A* will find the shortest path, but causes a lot of memory accesses, and worse, a lot of memory updates.  This is something to be avoided in a language like Scheme, which leans towards immutable variables and a functional style.

After a couple of hours of hacking, I ended up with is a routine that will find a path, if there is a path, but it will not always be the shortest.  If this algorithm starts going down a long and winding detour when there is a shorter path nearby, it will continue on down the longer path, get to the finish and call it a win.  And, as I discover in the future, it has a serious flaw which can cause it to take many seconds to find a simple path.

But in general, it is much faster at finding a path through an open space that has a few obstacles, while being a bit slower at solving mazes.

Here's a video of it solving a maze, and note the pause in animation at the beginning while the algorithm calculates the path to the end.

<embed src="mazerunner.mov" width="400" height="480" controller="true">

## More job improvements

Last update, I had a basic job system working.  I could put batches of jobs onto the job queue, and the robots would take a batch, work their way through it, then take another batch.

The batches looked a bit like this:

	moveTo	10,20
	pickUp  10,20
	moveTo   0,0
	drop	0,0

This is nice, but it has the drawback that every destination gets chosen when I create the batch.  In a game, it can be minutes between adding a job to the global queue and a robot picking it up, and in that time, a lot of obstacles can move around.  So I added a "job breakdown" system, which starts with a high level task, and then generates more detailed taskes until it creates something that it knows how to carry out. 

So to pick up an object, I now add

	fetch	10,10

to the global job queue.  A robot picks it up and expands it to

	pathTo	10,20
	pickUp  10,20
	pathTo   0,0
	drop	0,0
	
It then runs the pathing algorithm from above to expand the first "pathTo" instruction into a set of "moveTo" instructions

	moveTo	1,1
	moveTo	1,2
	moveTo	1,3
	moveTo	2,3
	... etc ...
	pickUp  10,20
	pathTo   0,0
	drop	0,0

The video above actually uses the jobs system to walk through the maze.  I just add

	pathTo 18,19

to the global jobs queue, and the only robot picks up the job, and starts following the path through the maze.

